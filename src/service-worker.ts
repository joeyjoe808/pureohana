/**
 * Custom Service Worker for Pure Ohana Photography
 *
 * Provides:
 * - Aggressive image caching with Cache API
 * - Offline fallback pages
 * - API response caching with network-first strategy
 * - Background sync for form submissions
 * - Push notification support
 */

/// <reference lib="webworker" />

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute, Route } from 'workbox-routing';
import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

declare const self: ServiceWorkerGlobalScope;

// Cache names
const CACHE_VERSION = 'v1';
const STATIC_CACHE = `pureohana-static-${CACHE_VERSION}`;
const IMAGE_CACHE = `pureohana-images-${CACHE_VERSION}`;
const API_CACHE = `pureohana-api-${CACHE_VERSION}`;
const FONT_CACHE = `pureohana-fonts-${CACHE_VERSION}`;

// Precache all assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Clean up old caches
cleanupOutdatedCaches();

/**
 * Cache images with Cache-First strategy
 * Images are cached indefinitely as they rarely change
 */
registerRoute(
  ({ request, url }) => {
    // Match image requests from Supabase Storage
    return (
      request.destination === 'image' ||
      url.hostname.includes('supabase.co') &&
      /\.(png|jpg|jpeg|webp|avif|svg|gif)$/i.test(url.pathname)
    );
  },
  new CacheFirst({
    cacheName: IMAGE_CACHE,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
        purgeOnQuotaError: true,
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

/**
 * Cache fonts with Cache-First strategy
 * Fonts never change, cache indefinitely
 */
registerRoute(
  ({ request, url }) => {
    return (
      request.destination === 'font' ||
      /\.(woff|woff2|ttf|eot)$/i.test(url.pathname)
    );
  },
  new CacheFirst({
    cacheName: FONT_CACHE,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

/**
 * Cache API responses with Network-First strategy
 * Try network first, fall back to cache if offline
 */
registerRoute(
  ({ url }) => {
    return (
      url.hostname.includes('supabase.co') &&
      url.pathname.includes('/rest/')
    );
  },
  new NetworkFirst({
    cacheName: API_CACHE,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 5, // 5 minutes
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
    networkTimeoutSeconds: 10,
  })
);

/**
 * Cache CSS and JS with Stale-While-Revalidate
 * Serve from cache, update in background
 */
registerRoute(
  ({ request }) => {
    return (
      request.destination === 'style' ||
      request.destination === 'script'
    );
  },
  new StaleWhileRevalidate({
    cacheName: STATIC_CACHE,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
      }),
    ],
  })
);

/**
 * Offline fallback page
 */
const OFFLINE_URL = '/offline.html';

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(STATIC_CACHE).then((cache) => {
      return cache.add(new Request(OFFLINE_URL, { cache: 'reload' }));
    })
  );

  // Force activation immediately
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  event.waitUntil(
    // Clean up old caches
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((cacheName) => {
            return (
              cacheName.startsWith('pureohana-') &&
              !cacheName.includes(CACHE_VERSION)
            );
          })
          .map((cacheName) => {
            console.log('Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          })
      );
    })
  );

  // Take control of all clients immediately
  self.clients.claim();
});

/**
 * Handle fetch events
 * Provide offline fallback for navigation requests
 */
self.addEventListener('fetch', (event) => {
  // Only handle navigation requests for offline fallback
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request).catch(() => {
        return caches.match(OFFLINE_URL) as Promise<Response>;
      })
    );
  }
});

/**
 * Background sync for form submissions
 * Queue form submissions when offline and sync when back online
 */
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-forms') {
    event.waitUntil(syncForms());
  }
});

async function syncForms() {
  try {
    // Retrieve queued form submissions from IndexedDB
    const db = await openDatabase();
    const forms = await getAllQueuedForms(db);

    // Submit each form
    for (const form of forms) {
      try {
        const response = await fetch(form.url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(form.data),
        });

        if (response.ok) {
          // Remove from queue
          await removeQueuedForm(db, form.id);
        }
      } catch (error) {
        console.error('Failed to sync form:', error);
      }
    }
  } catch (error) {
    console.error('Background sync failed:', error);
  }
}

/**
 * Push notification support
 */
self.addEventListener('push', (event) => {
  const options = {
    body: event.data?.text() || 'New notification from Pure Ohana',
    icon: '/pwa-192x192.png',
    badge: '/badge-72x72.png',
    vibrate: [100, 50, 100],
    data: {
      dateOfArrival: Date.now(),
      primaryKey: 1,
    },
    actions: [
      {
        action: 'explore',
        title: 'View',
        icon: '/icons/checkmark.png',
      },
      {
        action: 'close',
        title: 'Close',
        icon: '/icons/xmark.png',
      },
    ],
  };

  event.waitUntil(
    self.registration.showNotification('Pure Ohana Photography', options)
  );
});

self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  if (event.action === 'explore') {
    event.waitUntil(
      self.clients.openWindow('/')
    );
  }
});

/**
 * Message handler for cache management
 */
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }

  if (event.data && event.data.type === 'CLEAR_CACHE') {
    event.waitUntil(
      caches.keys().then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => {
            return caches.delete(cacheName);
          })
        );
      })
    );
  }

  if (event.data && event.data.type === 'CACHE_URLS') {
    const urlsToCache = event.data.payload;
    event.waitUntil(
      caches.open(IMAGE_CACHE).then((cache) => {
        return cache.addAll(urlsToCache);
      })
    );
  }
});

/**
 * IndexedDB helpers for background sync
 */
function openDatabase(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('pureohana-sync', 1);

    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);

    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result;
      if (!db.objectStoreNames.contains('forms')) {
        db.createObjectStore('forms', { keyPath: 'id', autoIncrement: true });
      }
    };
  });
}

async function getAllQueuedForms(db: IDBDatabase): Promise<any[]> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction('forms', 'readonly');
    const store = transaction.objectStore('forms');
    const request = store.getAll();

    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
  });
}

async function removeQueuedForm(db: IDBDatabase, id: number): Promise<void> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction('forms', 'readwrite');
    const store = transaction.objectStore('forms');
    const request = store.delete(id);

    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve();
  });
}

// Log service worker activation
console.log('Pure Ohana Service Worker activated');
